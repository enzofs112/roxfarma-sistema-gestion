================================================================================
    SISTEMA ROXFARMA - EXPLICACIÓN ACADÉMICA PARA EXPOSICIÓN
    Curso: Integrador de Sistemas
    Universidad Tecnológica del Perú (UTP)
================================================================================

Este documento contiene explicaciones detalladas de los conceptos, principios y
buenas prácticas aplicadas en el desarrollo del Sistema RoxFarma. Está diseñado
para facilitar el estudio y la exposición del proyecto.

================================================================================
ÍNDICE
================================================================================

1. ARQUITECTURA MVC (Modelo-Vista-Controlador)
2. PATRÓN DAO (Data Access Object)
3. PRINCIPIOS SOLID
4. INYECCIÓN DE DEPENDENCIAS (Con y Sin DI)
5. DESARROLLO GUIADO POR PRUEBAS (TDD)
6. SEGURIDAD: AUTENTICACIÓN Y AUTORIZACIÓN
7. FLUJO COMPLETO DE UNA OPERACIÓN
8. EJEMPLOS DE CÓDIGO COMENTADOS

================================================================================
1. ARQUITECTURA MVC (MODELO-VISTA-CONTROLADOR)
================================================================================

¿QUÉ ES MVC?
------------
MVC es un patrón de arquitectura que separa una aplicación en tres componentes
principales: Modelo, Vista y Controlador. Esta separación facilita el
mantenimiento, la escalabilidad y las pruebas del sistema.

COMPONENTES EN ROXFARMA:
------------------------

A) MODELO (Model)
   - Representa los datos y la lógica de negocio
   - En RoxFarma: Entidades JPA como Producto, Venta, Pedido, Usuario
   - Ubicación: paquete com.roxfarma.model

   Ejemplo:
   ```java
   @Entity
   @Table(name = "producto")
   public class Producto {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long idProducto;
       
       private String nombre;
       private BigDecimal precio;
       private Integer stock;
       
       @ManyToOne
       @JoinColumn(name = "id_categoria")
       private Categoria categoria;
       
       // Getters y Setters
   }
   ```
   
   Explicación: Esta clase representa un producto en la base de datos.
   Las anotaciones @Entity y @Table indican que es una entidad JPA.
   @ManyToOne establece la relación con Categoria.

B) VISTA (View)
   - Presenta los datos al usuario
   - En RoxFarma: Componentes React (frontend)
   - Ubicación: frontend/src/components
   
   Ejemplo:
   ```typescript
   export const ProductoList: React.FC = () => {
       const [productos, setProductos] = useState<Producto[]>([]);
       
       useEffect(() => {
           productoService.listarProductos()
               .then(data => setProductos(data));
       }, []);
       
       return (
           <table>
               <thead>
                   <tr>
                       <th>Nombre</th>
                       <th>Precio</th>
                       <th>Stock</th>
                   </tr>
               </thead>
               <tbody>
                   {productos.map(p => (
                       <tr key={p.idProducto}>
                           <td>{p.nombre}</td>
                           <td>S/ {p.precio}</td>
                           <td>{p.stock}</td>
                       </tr>
                   ))}
               </tbody>
           </table>
       );
   };
   ```
   
   Explicación: Este componente React muestra la lista de productos.
   Usa useState para manejar el estado y useEffect para cargar datos.
   No contiene lógica de negocio, solo presentación.

C) CONTROLADOR (Controller)
   - Maneja las peticiones del usuario
   - Coordina entre el Modelo y la Vista
   - En RoxFarma: Controladores REST con Spring
   - Ubicación: paquete com.roxfarma.controller
   
   Ejemplo:
   ```java
   @RestController
   @RequestMapping("/api/productos")
   public class ProductoController {
       
       private final ProductoService productoService;
       
       @Autowired
       public ProductoController(ProductoService productoService) {
           this.productoService = productoService;
       }
       
       @GetMapping
       public ResponseEntity<List<Producto>> listarProductos() {
           List<Producto> productos = productoService.listarTodosLosProductos();
           return ResponseEntity.ok(productos);
       }
       
       @PostMapping
       @PreAuthorize("hasRole('ADMINISTRADOR')")
       public ResponseEntity<Producto> crearProducto(@Valid @RequestBody ProductoDTO dto) {
           Producto producto = productoService.crearProducto(dto);
           return ResponseEntity.ok(producto);
       }
   }
   ```
   
   Explicación: El controlador recibe peticiones HTTP (GET, POST, etc.),
   delega la lógica al servicio (ProductoService) y retorna respuestas.
   @PreAuthorize controla el acceso según el rol del usuario.

VENTAJAS DE MVC EN ROXFARMA:
----------------------------
1. Separación de responsabilidades: Cada capa tiene un propósito específico
2. Mantenibilidad: Cambios en la vista no afectan al modelo
3. Reutilización: Los servicios pueden ser usados por múltiples controladores
4. Testabilidad: Cada capa puede probarse independientemente
5. Escalabilidad: Facilita agregar nuevas funcionalidades

FLUJO DE UNA PETICIÓN EN MVC:
-----------------------------
1. Usuario hace clic en "Listar Productos" (Vista)
2. Vista envía petición HTTP GET /api/productos (Controlador)
3. Controlador llama a productoService.listarTodosLosProductos() (Servicio)
4. Servicio consulta productoRepository.findAll() (Repositorio/DAO)
5. Repositorio consulta la base de datos y retorna entidades (Modelo)
6. Servicio procesa y retorna datos al Controlador
7. Controlador retorna ResponseEntity con JSON
8. Vista recibe JSON y actualiza la interfaz


================================================================================
2. PATRÓN DAO (DATA ACCESS OBJECT)
================================================================================

¿QUÉ ES DAO?
-----------
DAO es un patrón de diseño que encapsula toda la lógica de acceso a datos,
proporcionando una interfaz abstracta para la persistencia. Separa la lógica
de negocio de la lógica de acceso a datos.

ESTRUCTURA EN ROXFARMA:
----------------------

Interfaz Repository (DAO) → Spring Data JPA → Base de Datos MySQL

EJEMPLO DE DAO EN ROXFARMA:
--------------------------

```java
// Interfaz del repositorio (DAO)
@Repository
public interface ProductoRepository extends JpaRepository<Producto, Long> {
    
    // Métodos CRUD heredados automáticamente:
    // - save(Producto)
    // - findById(Long)
    // - findAll()
    // - deleteById(Long)
    
    // Métodos personalizados para consultas específicas
    List<Producto> findByStockLessThan(Integer umbral);
    
    List<Producto> findByFechaVencimientoBefore(LocalDate fecha);
    
    List<Producto> findByCategoria(Categoria categoria);
    
    @Query("SELECT p FROM Producto p WHERE p.nombre LIKE %:nombre%")
    List<Producto> buscarPorNombre(@Param("nombre") String nombre);
}
```

Explicación:
- @Repository marca la interfaz como componente de acceso a datos
- JpaRepository<Producto, Long> proporciona operaciones CRUD automáticas
- Spring Data JPA genera la implementación automáticamente
- Los métodos personalizados siguen convenciones de nombres
- @Query permite consultas JPQL personalizadas

USO DEL DAO EN UN SERVICIO:
---------------------------

```java
@Service
public class ProductoService {
    
    // Inyectamos el DAO (Repository)
    private final ProductoRepository productoRepository;
    
    @Autowired
    public ProductoService(ProductoRepository productoRepository) {
        this.productoRepository = productoRepository;
    }
    
    // Método de negocio que usa el DAO
    public List<Producto> obtenerProductosConStockBajo(Integer umbral) {
        // El servicio delega el acceso a datos al DAO
        List<Producto> productos = productoRepository.findByStockLessThan(umbral);
        
        // Aquí podríamos agregar lógica de negocio adicional
        // Por ejemplo, registrar en log, enviar notificaciones, etc.
        log.info("Se encontraron {} productos con stock bajo", productos.size());
        
        return productos;
    }
}
```

VENTAJAS DEL PATRÓN DAO:
-----------------------
1. Desacoplamiento: La lógica de negocio no depende de cómo se accede a los datos
2. Mantenibilidad: Cambios en la base de datos no afectan a los servicios
3. Reutilización: Un mismo DAO puede ser usado por múltiples servicios
4. Testabilidad: Fácil crear mocks del DAO para pruebas unitarias
5. Abstracción: Oculta los detalles de implementación de persistencia

COMPARACIÓN: CON DAO vs SIN DAO
-------------------------------

SIN DAO (❌ MAL):
```java
@Service
public class ProductoService {
    
    @Autowired
    private EntityManager entityManager;
    
    public List<Producto> obtenerProductosConStockBajo(Integer umbral) {
        // Lógica de acceso a datos mezclada con lógica de negocio
        String sql = "SELECT * FROM producto WHERE stock < ?";
        Query query = entityManager.createNativeQuery(sql, Producto.class);
        query.setParameter(1, umbral);
        return query.getResultList();
    }
}
```
Problemas: Código SQL en el servicio, difícil de probar, acoplamiento fuerte.

CON DAO (✅ BIEN):
```java
@Service
public class ProductoService {
    
    private final ProductoRepository productoRepository;
    
    @Autowired
    public ProductoService(ProductoRepository productoRepository) {
        this.productoRepository = productoRepository;
    }
    
    public List<Producto> obtenerProductosConStockBajo(Integer umbral) {
        // Lógica de negocio separada del acceso a datos
        return productoRepository.findByStockLessThan(umbral);
    }
}
```
Ventajas: Separación clara, fácil de probar, desacoplado.

REPOSITORIOS EN ROXFARMA:
-------------------------
- ProductoRepository: Acceso a datos de productos
- VentaRepository: Acceso a datos de ventas
- PedidoRepository: Acceso a datos de pedidos
- UsuarioRepository: Acceso a datos de usuarios
- ClienteRepository: Acceso a datos de clientes
- ProveedorRepository: Acceso a datos de proveedores
- CategoriaRepository: Acceso a datos de categorías


================================================================================
3. PRINCIPIOS SOLID
================================================================================

SOLID es un acrónimo de cinco principios de diseño orientado a objetos que
hacen el software más comprensible, flexible y mantenible.

--------------------------------------------------------------------------------
3.1 SINGLE RESPONSIBILITY PRINCIPLE (SRP)
    Principio de Responsabilidad Única
--------------------------------------------------------------------------------

DEFINICIÓN:
Una clase debe tener una única razón para cambiar, es decir, una única
responsabilidad.

APLICACIÓN EN ROXFARMA:

✅ BIEN - Cada clase tiene una responsabilidad:

```java
// Responsabilidad: Acceso a datos de productos
@Repository
public interface ProductoRepository extends JpaRepository<Producto, Long> {
    List<Producto> findByStockLessThan(Integer umbral);
}

// Responsabilidad: Lógica de negocio de productos
@Service
public class ProductoService {
    public Producto crearProducto(ProductoDTO dto) {
        // Solo lógica de negocio
    }
}

// Responsabilidad: Manejo de peticiones HTTP
@RestController
public class ProductoController {
    public ResponseEntity<Producto> crear(@RequestBody ProductoDTO dto) {
        // Solo manejo de HTTP
    }
}

// Responsabilidad: Generación de PDFs
@Service
public class BoletaService {
    public byte[] generarBoletaPDF(Long idVenta) {
        // Solo generación de PDFs
    }
}
```

❌ MAL - Una clase con múltiples responsabilidades:

```java
@Service
public class ProductoService {
    
    // Responsabilidad 1: Lógica de negocio
    public Producto crearProducto(ProductoDTO dto) { }
    
    // Responsabilidad 2: Acceso a datos (debería estar en Repository)
    public void guardarEnBaseDatos(Producto producto) { }
    
    // Responsabilidad 3: Generación de reportes (debería estar en ReporteService)
    public byte[] generarReportePDF() { }
    
    // Responsabilidad 4: Envío de emails (debería estar en NotificacionService)
    public void enviarEmailStockBajo() { }
}
```

VENTAJAS EN ROXFARMA:
- Fácil localizar dónde hacer cambios
- Clases más pequeñas y comprensibles
- Menor riesgo de efectos secundarios al modificar código

--------------------------------------------------------------------------------
3.2 OPEN/CLOSED PRINCIPLE (OCP)
    Principio Abierto/Cerrado
--------------------------------------------------------------------------------

DEFINICIÓN:
Las entidades de software deben estar abiertas para extensión pero cerradas
para modificación.

APLICACIÓN EN ROXFARMA:

✅ BIEN - Extensible sin modificar código existente:

```java
// Interfaz base para generadores de reportes
public interface GeneradorReporte {
    byte[] generarReporte(List<Venta> ventas);
}

// Implementación para PDF
@Service
public class GeneradorReportePDF implements GeneradorReporte {
    @Override
    public byte[] generarReporte(List<Venta> ventas) {
        // Lógica para generar PDF
        return pdfBytes;
    }
}

// Nueva implementación para Excel (EXTENSIÓN sin modificar código existente)
@Service
public class GeneradorReporteExcel implements GeneradorReporte {
    @Override
    public byte[] generarReporte(List<Venta> ventas) {
        // Lógica para generar Excel
        return excelBytes;
    }
}

// El servicio usa la interfaz, no implementaciones concretas
@Service
public class ReporteService {
    
    private final GeneradorReporte generador;
    
    // Se puede inyectar cualquier implementación
    public ReporteService(GeneradorReporte generador) {
        this.generador = generador;
    }
    
    public byte[] generarReporte(List<Venta> ventas) {
        return generador.generarReporte(ventas);
    }
}
```

❌ MAL - Requiere modificar código para agregar funcionalidad:

```java
@Service
public class ReporteService {
    
    public byte[] generarReporte(List<Venta> ventas, String tipo) {
        if (tipo.equals("PDF")) {
            // Generar PDF
        } else if (tipo.equals("EXCEL")) {
            // Generar Excel
        }
        // Para agregar CSV, hay que modificar este método (VIOLACIÓN OCP)
    }
}
```

VENTAJAS EN ROXFARMA:
- Agregar nuevos tipos de reportes sin modificar código existente
- Menor riesgo de introducir bugs en funcionalidad existente
- Facilita el crecimiento del sistema

--------------------------------------------------------------------------------
3.3 LISKOV SUBSTITUTION PRINCIPLE (LSP)
    Principio de Sustitución de Liskov
--------------------------------------------------------------------------------

DEFINICIÓN:
Los objetos de una clase derivada deben poder reemplazar objetos de la clase
base sin alterar el comportamiento del programa.

APLICACIÓN EN ROXFARMA:

✅ BIEN - Las subclases respetan el contrato de la clase base:

```java
// Clase base abstracta
public abstract class Documento {
    protected Long id;
    protected LocalDateTime fecha;
    
    // Contrato: calcular el total del documento
    public abstract BigDecimal calcularTotal();
}

// Subclase que respeta el contrato
public class Venta extends Documento {
    private List<DetalleVenta> detalles;
    
    @Override
    public BigDecimal calcularTotal() {
        // Implementación correcta que retorna el total
        return detalles.stream()
            .map(d -> d.getPrecio().multiply(BigDecimal.valueOf(d.getCantidad())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

// Otra subclase que también respeta el contrato
public class Pedido extends Documento {
    private List<DetallePedido> detalles;
    
    @Override
    public BigDecimal calcularTotal() {
        // Implementación correcta que retorna el total
        return detalles.stream()
            .map(d -> d.getPrecio().multiply(BigDecimal.valueOf(d.getCantidad())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

// Uso polimórfico - funciona con cualquier subclase
public void procesarDocumento(Documento documento) {
    BigDecimal total = documento.calcularTotal();
    System.out.println("Total: " + total);
}
```

VENTAJAS EN ROXFARMA:
- Polimorfismo seguro
- Código más flexible y reutilizable
- Facilita el uso de patrones de diseño


--------------------------------------------------------------------------------
3.4 INTERFACE SEGREGATION PRINCIPLE (ISP)
    Principio de Segregación de Interfaces
--------------------------------------------------------------------------------

DEFINICIÓN:
Los clientes no deben ser obligados a depender de interfaces que no usan.
Es mejor tener varias interfaces específicas que una interfaz general.

APLICACIÓN EN ROXFARMA:

❌ MAL - Interfaz grande que obliga a implementar métodos innecesarios:

```java
// Interfaz demasiado grande
public interface OperacionesCompletas {
    void crear();
    void actualizar();
    void eliminar();
    void exportarPDF();
    void exportarExcel();
    void enviarEmail();
    void generarReporte();
}

// ProductoService se ve obligado a implementar métodos que no necesita
@Service
public class ProductoService implements OperacionesCompletas {
    public void crear() { /* implementación */ }
    public void actualizar() { /* implementación */ }
    public void eliminar() { /* implementación */ }
    
    // Métodos que no necesita pero debe implementar
    public void exportarPDF() { throw new UnsupportedOperationException(); }
    public void exportarExcel() { throw new UnsupportedOperationException(); }
    public void enviarEmail() { throw new UnsupportedOperationException(); }
    public void generarReporte() { throw new UnsupportedOperationException(); }
}
```

✅ BIEN - Interfaces segregadas y específicas:

```java
// Interfaces pequeñas y específicas
public interface Persistible {
    void guardar();
}

public interface Actualizable {
    void actualizar();
}

public interface Eliminable {
    void eliminar();
}

public interface Exportable {
    byte[] exportar();
}

// Cada clase implementa solo lo que necesita
@Service
public class ProductoService implements Persistible, Actualizable, Eliminable {
    @Override
    public void guardar() {
        // Implementación
    }
    
    @Override
    public void actualizar() {
        // Implementación
    }
    
    @Override
    public void eliminar() {
        // Implementación
    }
}

@Service
public class ReporteService implements Exportable {
    @Override
    public byte[] exportar() {
        // Implementación
    }
}
```

VENTAJAS EN ROXFARMA:
- Clases más cohesivas
- No se obliga a implementar métodos innecesarios
- Interfaces más fáciles de entender y mantener

--------------------------------------------------------------------------------
3.5 DEPENDENCY INVERSION PRINCIPLE (DIP)
    Principio de Inversión de Dependencias
--------------------------------------------------------------------------------

DEFINICIÓN:
1. Los módulos de alto nivel no deben depender de módulos de bajo nivel.
   Ambos deben depender de abstracciones.
2. Las abstracciones no deben depender de detalles.
   Los detalles deben depender de abstracciones.

APLICACIÓN EN ROXFARMA:

❌ MAL - Dependencia de implementaciones concretas:

```java
@Service
public class VentaService {
    
    // Dependencia directa de implementaciones concretas (bajo nivel)
    private VentaRepositoryImpl ventaRepository = new VentaRepositoryImpl();
    private MySQLInventarioService inventarioService = new MySQLInventarioService();
    
    public Venta registrarVenta(VentaDTO dto) {
        // Lógica de negocio
    }
}
```

Problemas:
- Acoplamiento fuerte a implementaciones específicas
- Difícil cambiar la implementación
- Imposible hacer pruebas con mocks

✅ BIEN - Dependencia de abstracciones (interfaces):

```java
@Service
public class VentaService {
    
    // Dependencia de abstracciones (interfaces), no implementaciones
    private final VentaRepository ventaRepository;
    private final InventarioService inventarioService;
    private final NotificacionService notificacionService;
    
    // Las dependencias se inyectan (Inversión de Control)
    @Autowired
    public VentaService(VentaRepository ventaRepository,
                       InventarioService inventarioService,
                       NotificacionService notificacionService) {
        this.ventaRepository = ventaRepository;
        this.inventarioService = inventarioService;
        this.notificacionService = notificacionService;
    }
    
    public Venta registrarVenta(VentaDTO dto) {
        // Lógica de negocio usando las abstracciones
        Venta venta = crearVenta(dto);
        ventaRepository.save(venta);
        inventarioService.actualizarStock(venta);
        notificacionService.enviarConfirmacion(venta);
        return venta;
    }
}

// Las implementaciones concretas se inyectan en tiempo de ejecución
@Repository
public interface VentaRepository extends JpaRepository<Venta, Long> {
    // Spring Data JPA proporciona la implementación
}
```

VENTAJAS EN ROXFARMA:
- Desacoplamiento entre capas
- Fácil cambiar implementaciones
- Facilita pruebas unitarias con mocks
- Mayor flexibilidad y mantenibilidad

RESUMEN SOLID EN ROXFARMA:
--------------------------
S - Cada clase tiene una única responsabilidad (Controller, Service, Repository)
O - Extensible mediante interfaces (GeneradorReporte)
L - Las subclases respetan contratos (Venta, Pedido extienden Documento)
I - Interfaces específicas (Persistible, Exportable)
D - Dependencia de abstracciones mediante inyección de dependencias


================================================================================
4. INYECCIÓN DE DEPENDENCIAS (DEPENDENCY INJECTION)
================================================================================

¿QUÉ ES LA INYECCIÓN DE DEPENDENCIAS?
-------------------------------------
La Inyección de Dependencias (DI) es un patrón de diseño que implementa el
principio de Inversión de Dependencias (D de SOLID). En lugar de que una clase
cree sus propias dependencias, estas se "inyectan" desde el exterior.

--------------------------------------------------------------------------------
4.1 EJEMPLO SIN INYECCIÓN DE DEPENDENCIAS (❌ MAL)
--------------------------------------------------------------------------------

```java
@Service
public class VentaService {
    
    // La clase crea directamente sus dependencias (ACOPLAMIENTO FUERTE)
    private VentaRepository ventaRepository = new VentaRepositoryImpl();
    private ProductoRepository productoRepository = new ProductoRepositoryImpl();
    private ClienteRepository clienteRepository = new ClienteRepositoryImpl();
    private InventarioService inventarioService = new InventarioService();
    private BoletaService boletaService = new BoletaService();
    
    public Venta registrarVenta(VentaDTO dto) {
        // Validar cliente
        Cliente cliente = clienteRepository.findById(dto.getIdCliente());
        
        // Validar productos y stock
        for (DetalleVentaDTO detalle : dto.getDetalles()) {
            Producto producto = productoRepository.findById(detalle.getIdProducto());
            if (producto.getStock() < detalle.getCantidad()) {
                throw new StockInsuficienteException("Stock insuficiente");
            }
        }
        
        // Crear venta
        Venta venta = new Venta();
        venta.setCliente(cliente);
        venta.setTotal(calcularTotal(dto));
        
        // Guardar venta
        ventaRepository.save(venta);
        
        // Actualizar inventario
        inventarioService.disminuirStock(venta);
        
        return venta;
    }
}
```

PROBLEMAS DE ESTE ENFOQUE:
--------------------------
1. ACOPLAMIENTO FUERTE: VentaService está fuertemente acoplado a implementaciones
   concretas. Si queremos cambiar VentaRepositoryImpl por otra implementación,
   debemos modificar el código de VentaService.

2. DIFÍCIL DE PROBAR: No podemos hacer pruebas unitarias con mocks porque las
   dependencias se crean internamente con "new". No hay forma de inyectar
   versiones de prueba.

3. VIOLA SOLID: Viola el principio de Inversión de Dependencias porque depende
   de implementaciones concretas, no de abstracciones.

4. NO REUTILIZABLE: Si otra clase necesita las mismas dependencias, debe
   crearlas nuevamente, duplicando código.

5. DIFÍCIL MANTENIMIENTO: Cualquier cambio en las dependencias requiere
   modificar VentaService.

--------------------------------------------------------------------------------
4.2 EJEMPLO CON INYECCIÓN DE DEPENDENCIAS (✅ BIEN)
--------------------------------------------------------------------------------

```java
@Service
public class VentaService {
    
    // Las dependencias se declaran como interfaces (ABSTRACCIONES)
    private final VentaRepository ventaRepository;
    private final ProductoRepository productoRepository;
    private final ClienteRepository clienteRepository;
    private final InventarioService inventarioService;
    private final BoletaService boletaService;
    
    // Spring inyecta las dependencias mediante el constructor
    // @Autowired es opcional en constructores únicos desde Spring 4.3
    @Autowired
    public VentaService(VentaRepository ventaRepository,
                       ProductoRepository productoRepository,
                       ClienteRepository clienteRepository,
                       InventarioService inventarioService,
                       BoletaService boletaService) {
        this.ventaRepository = ventaRepository;
        this.productoRepository = productoRepository;
        this.clienteRepository = clienteRepository;
        this.inventarioService = inventarioService;
        this.boletaService = boletaService;
    }
    
    public Venta registrarVenta(VentaDTO dto) {
        // Validar cliente
        Cliente cliente = clienteRepository.findById(dto.getIdCliente())
            .orElseThrow(() -> new ResourceNotFoundException("Cliente no encontrado"));
        
        // Validar productos y stock
        for (DetalleVentaDTO detalle : dto.getDetalles()) {
            Producto producto = productoRepository.findById(detalle.getIdProducto())
                .orElseThrow(() -> new ResourceNotFoundException("Producto no encontrado"));
            
            if (producto.getStock() < detalle.getCantidad()) {
                throw new StockInsuficienteException(
                    String.format("Stock insuficiente para %s. Disponible: %d, Solicitado: %d",
                        producto.getNombre(), producto.getStock(), detalle.getCantidad())
                );
            }
        }
        
        // Crear venta
        Venta venta = new Venta();
        venta.setCliente(cliente);
        venta.setFecha(LocalDateTime.now());
        venta.setTotal(calcularTotal(dto));
        
        // Crear detalles
        List<DetalleVenta> detalles = crearDetalles(dto, venta);
        venta.setDetalles(detalles);
        
        // Guardar venta (transaccional)
        venta = ventaRepository.save(venta);
        
        // Actualizar inventario
        for (DetalleVenta detalle : detalles) {
            inventarioService.disminuirStock(
                detalle.getProducto().getIdProducto(),
                detalle.getCantidad(),
                "VENTA"
            );
        }
        
        return venta;
    }
    
    private BigDecimal calcularTotal(VentaDTO dto) {
        BigDecimal subtotal = BigDecimal.ZERO;
        
        for (DetalleVentaDTO detalle : dto.getDetalles()) {
            Producto producto = productoRepository.findById(detalle.getIdProducto()).get();
            BigDecimal precioDetalle = producto.getPrecio()
                .multiply(BigDecimal.valueOf(detalle.getCantidad()));
            subtotal = subtotal.add(precioDetalle);
        }
        
        // Calcular IGV (18%)
        BigDecimal igv = subtotal.multiply(new BigDecimal("0.18"));
        
        // Total = Subtotal + IGV
        return subtotal.add(igv);
    }
}
```

VENTAJAS DE ESTE ENFOQUE:
-------------------------
1. DESACOPLAMIENTO: VentaService depende de interfaces, no de implementaciones
   concretas. Podemos cambiar la implementación sin modificar VentaService.

2. FÁCIL DE PROBAR: Podemos inyectar mocks en las pruebas unitarias:
   ```java
   @ExtendWith(MockitoExtension.class)
   class VentaServiceTest {
       @Mock
       private VentaRepository ventaRepository;
       
       @Mock
       private ProductoRepository productoRepository;
       
       @InjectMocks
       private VentaService ventaService;
       
       @Test
       void debeRegistrarVentaCorrectamente() {
           // Configurar mocks
           when(clienteRepository.findById(1L)).thenReturn(Optional.of(cliente));
           
           // Ejecutar prueba
           Venta venta = ventaService.registrarVenta(dto);
           
           // Verificar
           assertNotNull(venta);
       }
   }
   ```

3. CUMPLE SOLID: Cumple con el principio de Inversión de Dependencias al
   depender de abstracciones (interfaces).

4. REUTILIZABLE: Spring gestiona las instancias (singletons por defecto),
   reutilizando las mismas dependencias en toda la aplicación.

5. FÁCIL MANTENIMIENTO: Los cambios en las dependencias no afectan a VentaService.

6. GESTIÓN AUTOMÁTICA: Spring gestiona el ciclo de vida de los objetos
   (creación, inyección, destrucción).


--------------------------------------------------------------------------------
4.3 TIPOS DE INYECCIÓN DE DEPENDENCIAS EN SPRING
--------------------------------------------------------------------------------

A) INYECCIÓN POR CONSTRUCTOR (✅ RECOMENDADA)
```java
@Service
public class ProductoService {
    
    private final ProductoRepository productoRepository;
    private final CategoriaRepository categoriaRepository;
    
    @Autowired // Opcional en constructores únicos
    public ProductoService(ProductoRepository productoRepository,
                          CategoriaRepository categoriaRepository) {
        this.productoRepository = productoRepository;
        this.categoriaRepository = categoriaRepository;
    }
}
```
Ventajas:
- Dependencias inmutables (final)
- Fácil de probar
- Dependencias obligatorias
- Recomendada por Spring

B) INYECCIÓN POR SETTER (No recomendada)
```java
@Service
public class ProductoService {
    
    private ProductoRepository productoRepository;
    
    @Autowired
    public void setProductoRepository(ProductoRepository productoRepository) {
        this.productoRepository = productoRepository;
    }
}
```
Desventajas:
- Dependencias mutables
- Dependencias opcionales (puede ser null)

C) INYECCIÓN POR CAMPO (No recomendada)
```java
@Service
public class ProductoService {
    
    @Autowired
    private ProductoRepository productoRepository;
}
```
Desventajas:
- Difícil de probar (no se pueden inyectar mocks fácilmente)
- Dependencias ocultas
- Viola encapsulación

--------------------------------------------------------------------------------
4.4 ANOTACIONES DE SPRING PARA INYECCIÓN DE DEPENDENCIAS
--------------------------------------------------------------------------------

@Component  - Marca una clase como componente de Spring (genérico)
@Service    - Especialización de @Component para capa de servicio (lógica de negocio)
@Repository - Especialización de @Component para capa de datos (acceso a BD)
@Controller - Especialización de @Component para controladores web (MVC)
@RestController - Combinación de @Controller + @ResponseBody (API REST)

@Autowired  - Indica que Spring debe inyectar la dependencia automáticamente

Ejemplo completo:
```java
// Repositorio
@Repository
public interface ProductoRepository extends JpaRepository<Producto, Long> {
}

// Servicio
@Service
public class ProductoService {
    
    private final ProductoRepository productoRepository;
    
    @Autowired
    public ProductoService(ProductoRepository productoRepository) {
        this.productoRepository = productoRepository;
    }
    
    public Producto crearProducto(ProductoDTO dto) {
        Producto producto = new Producto();
        producto.setNombre(dto.getNombre());
        producto.setPrecio(dto.getPrecio());
        return productoRepository.save(producto);
    }
}

// Controlador
@RestController
@RequestMapping("/api/productos")
public class ProductoController {
    
    private final ProductoService productoService;
    
    @Autowired
    public ProductoController(ProductoService productoService) {
        this.productoService = productoService;
    }
    
    @PostMapping
    public ResponseEntity<Producto> crear(@RequestBody ProductoDTO dto) {
        Producto producto = productoService.crearProducto(dto);
        return ResponseEntity.ok(producto);
    }
}
```

FLUJO DE INYECCIÓN:
1. Spring escanea las clases con anotaciones (@Service, @Repository, etc.)
2. Crea instancias de estas clases (beans)
3. Identifica las dependencias (parámetros del constructor con @Autowired)
4. Inyecta las dependencias automáticamente
5. Gestiona el ciclo de vida de los beans

--------------------------------------------------------------------------------
4.5 VENTAJAS DE LA INYECCIÓN DE DEPENDENCIAS EN ROXFARMA
--------------------------------------------------------------------------------

1. MANTENIBILIDAD:
   - Cambios en las dependencias no afectan a las clases que las usan
   - Fácil agregar nuevas funcionalidades

2. MODULARIDAD:
   - Cada componente es independiente
   - Fácil reutilizar componentes en diferentes contextos

3. TESTABILIDAD:
   - Fácil crear pruebas unitarias con mocks
   - No necesitamos base de datos real para probar servicios

4. FLEXIBILIDAD:
   - Fácil cambiar implementaciones (ej: cambiar de MySQL a PostgreSQL)
   - Podemos tener múltiples implementaciones de una interfaz

5. INVERSIÓN DE CONTROL:
   - Spring gestiona la creación y ciclo de vida de objetos
   - No necesitamos usar "new" para crear dependencias

EJEMPLO DE PRUEBA UNITARIA CON DI:
```java
@ExtendWith(MockitoExtension.class)
class VentaServiceTest {
    
    @Mock
    private VentaRepository ventaRepository;
    
    @Mock
    private ProductoRepository productoRepository;
    
    @Mock
    private ClienteRepository clienteRepository;
    
    @Mock
    private InventarioService inventarioService;
    
    @InjectMocks
    private VentaService ventaService;
    
    @Test
    void debeRegistrarVentaCorrectamente() {
        // Arrange: Configurar mocks
        Cliente cliente = new Cliente();
        cliente.setIdCliente(1L);
        
        Producto producto = new Producto();
        producto.setIdProducto(1L);
        producto.setPrecio(new BigDecimal("15.00"));
        producto.setStock(50);
        
        when(clienteRepository.findById(1L)).thenReturn(Optional.of(cliente));
        when(productoRepository.findById(1L)).thenReturn(Optional.of(producto));
        when(ventaRepository.save(any(Venta.class))).thenAnswer(i -> i.getArgument(0));
        
        // Act: Ejecutar método
        VentaDTO dto = crearVentaDTO();
        Venta resultado = ventaService.registrarVenta(dto);
        
        // Assert: Verificar resultados
        assertNotNull(resultado);
        assertEquals(cliente, resultado.getCliente());
        verify(inventarioService, times(1)).disminuirStock(anyLong(), anyInt(), anyString());
    }
}
```

Sin DI, esta prueba sería imposible porque VentaService crearía sus propias
dependencias con "new", y no podríamos inyectar mocks.


================================================================================
5. DESARROLLO GUIADO POR PRUEBAS (TDD - TEST DRIVEN DEVELOPMENT)
================================================================================

¿QUÉ ES TDD?
-----------
TDD es una metodología de desarrollo donde escribimos las pruebas ANTES de
escribir el código de producción. Sigue el ciclo: Red → Green → Refactor.

CICLO TDD:
---------
1. RED (Rojo): Escribir una prueba que falle
2. GREEN (Verde): Escribir el código mínimo para que la prueba pase
3. REFACTOR: Mejorar el código manteniendo las pruebas verdes

--------------------------------------------------------------------------------
5.1 EJEMPLO DE TDD EN ROXFARMA: ProductoService
--------------------------------------------------------------------------------

PASO 1: RED - Escribir prueba que falla
```java
@ExtendWith(MockitoExtension.class)
class ProductoServiceTest {
    
    @Mock
    private ProductoRepository productoRepository;
    
    @Mock
    private CategoriaRepository categoriaRepository;
    
    @InjectMocks
    private ProductoService productoService;
    
    @Test
    @DisplayName("Debe crear un producto correctamente")
    void debeCrearProductoCorrectamente() {
        // Arrange (Preparar datos de prueba)
        ProductoDTO dto = new ProductoDTO();
        dto.setNombre("Paracetamol");
        dto.setPrecio(new BigDecimal("15.50"));
        dto.setStock(100);
        dto.setIdCategoria(1L);
        
        Categoria categoria = new Categoria();
        categoria.setIdCategoria(1L);
        categoria.setNombre("Analgésicos");
        
        // Configurar comportamiento de mocks
        when(categoriaRepository.findById(1L)).thenReturn(Optional.of(categoria));
        when(productoRepository.save(any(Producto.class))).thenAnswer(i -> i.getArgument(0));
        
        // Act (Ejecutar el método a probar)
        Producto resultado = productoService.crearProducto(dto);
        
        // Assert (Verificar resultados)
        assertNotNull(resultado);
        assertEquals("Paracetamol", resultado.getNombre());
        assertEquals(new BigDecimal("15.50"), resultado.getPrecio());
        assertEquals(100, resultado.getStock());
        assertEquals(categoria, resultado.getCategoria());
        
        // Verificar que se llamó al repositorio
        verify(productoRepository, times(1)).save(any(Producto.class));
    }
}
```

Esta prueba FALLA porque ProductoService.crearProducto() aún no existe.

PASO 2: GREEN - Escribir código mínimo para que pase
```java
@Service
public class ProductoService {
    
    private final ProductoRepository productoRepository;
    private final CategoriaRepository categoriaRepository;
    
    @Autowired
    public ProductoService(ProductoRepository productoRepository,
                          CategoriaRepository categoriaRepository) {
        this.productoRepository = productoRepository;
        this.categoriaRepository = categoriaRepository;
    }
    
    public Producto crearProducto(ProductoDTO dto) {
        // Buscar categoría
        Categoria categoria = categoriaRepository.findById(dto.getIdCategoria())
            .orElseThrow(() -> new ResourceNotFoundException(
                "Categoría no encontrada con ID: " + dto.getIdCategoria()
            ));
        
        // Crear producto
        Producto producto = new Producto();
        producto.setNombre(dto.getNombre());
        producto.setPrecio(dto.getPrecio());
        producto.setStock(dto.getStock());
        producto.setCategoria(categoria);
        
        // Guardar y retornar
        return productoRepository.save(producto);
    }
}
```

Ahora la prueba PASA (verde).

PASO 3: REFACTOR - Mejorar el código
```java
@Service
@Slf4j // Agregar logging
public class ProductoService {
    
    private final ProductoRepository productoRepository;
    private final CategoriaRepository categoriaRepository;
    
    @Autowired
    public ProductoService(ProductoRepository productoRepository,
                          CategoriaRepository categoriaRepository) {
        this.productoRepository = productoRepository;
        this.categoriaRepository = categoriaRepository;
    }
    
    public Producto crearProducto(ProductoDTO dto) {
        log.info("Creando producto: {}", dto.getNombre());
        
        // Buscar categoría
        Categoria categoria = categoriaRepository.findById(dto.getIdCategoria())
            .orElseThrow(() -> new ResourceNotFoundException(
                "Categoría no encontrada con ID: " + dto.getIdCategoria()
            ));
        
        // Crear producto usando método auxiliar
        Producto producto = mapearDTOaEntidad(dto, categoria);
        
        // Guardar y retornar
        Producto productoGuardado = productoRepository.save(producto);
        log.info("Producto creado exitosamente con ID: {}", productoGuardado.getIdProducto());
        
        return productoGuardado;
    }
    
    // Método auxiliar para mapear DTO a entidad
    private Producto mapearDTOaEntidad(ProductoDTO dto, Categoria categoria) {
        Producto producto = new Producto();
        producto.setNombre(dto.getNombre());
        producto.setDescripcion(dto.getDescripcion());
        producto.setPrecio(dto.getPrecio());
        producto.setStock(dto.getStock());
        producto.setFechaVencimiento(dto.getFechaVencimiento());
        producto.setCategoria(categoria);
        return producto;
    }
}
```

Las pruebas siguen pasando después del refactor.

--------------------------------------------------------------------------------
5.2 EJEMPLO DE PRUEBA: Validación de Stock Insuficiente
--------------------------------------------------------------------------------

```java
@Test
@DisplayName("Debe lanzar excepción cuando el stock es insuficiente")
void debeLanzarExcepcionCuandoStockInsuficiente() {
    // Arrange
    Cliente cliente = new Cliente();
    cliente.setIdCliente(1L);
    
    Producto producto = new Producto();
    producto.setIdProducto(1L);
    producto.setNombre("Paracetamol");
    producto.setStock(3); // Stock insuficiente
    
    DetalleVentaDTO detalleDTO = new DetalleVentaDTO();
    detalleDTO.setIdProducto(1L);
    detalleDTO.setCantidad(5); // Solicita más de lo disponible
    
    VentaDTO ventaDTO = new VentaDTO();
    ventaDTO.setIdCliente(1L);
    ventaDTO.setDetalles(Arrays.asList(detalleDTO));
    
    when(clienteRepository.findById(1L)).thenReturn(Optional.of(cliente));
    when(productoRepository.findById(1L)).thenReturn(Optional.of(producto));
    
    // Act & Assert
    StockInsuficienteException exception = assertThrows(
        StockInsuficienteException.class,
        () -> ventaService.registrarVenta(ventaDTO)
    );
    
    // Verificar mensaje de error
    assertTrue(exception.getMessage().contains("Stock insuficiente"));
    
    // Verificar que NO se guardó la venta
    verify(ventaRepository, never()).save(any(Venta.class));
    
    // Verificar que NO se actualizó el inventario
    verify(inventarioService, never()).disminuirStock(anyLong(), anyInt(), anyString());
}
```

--------------------------------------------------------------------------------
5.3 ESTRUCTURA DE UNA PRUEBA UNITARIA
--------------------------------------------------------------------------------

Patrón AAA (Arrange-Act-Assert):

1. ARRANGE (Preparar):
   - Configurar datos de prueba
   - Configurar mocks
   - Preparar el escenario

2. ACT (Actuar):
   - Ejecutar el método que se está probando
   - Capturar el resultado

3. ASSERT (Afirmar):
   - Verificar que el resultado es el esperado
   - Verificar que se llamaron los métodos correctos
   - Verificar el estado final

Ejemplo:
```java
@Test
void debeCalcularTotalConIGVCorrectamente() {
    // ARRANGE: Preparar datos
    VentaDTO dto = crearVentaDTOConDosProductos();
    configurarMocksParaVenta();
    
    // ACT: Ejecutar método
    Venta resultado = ventaService.registrarVenta(dto);
    
    // ASSERT: Verificar resultado
    assertEquals(new BigDecimal("413.00"), resultado.getTotal());
}
```

--------------------------------------------------------------------------------
5.4 VENTAJAS DE TDD EN ROXFARMA
--------------------------------------------------------------------------------

1. CÓDIGO MÁS CONFIABLE:
   - Las pruebas garantizan que el código funciona correctamente
   - Detecta bugs tempranamente

2. MEJOR DISEÑO:
   - Escribir pruebas primero fuerza a pensar en el diseño
   - Código más modular y desacoplado

3. DOCUMENTACIÓN VIVA:
   - Las pruebas documentan cómo usar el código
   - Ejemplos de uso reales

4. REFACTORING SEGURO:
   - Podemos mejorar el código sin miedo a romper funcionalidad
   - Las pruebas nos avisan si algo se rompe

5. MENOS BUGS EN PRODUCCIÓN:
   - Los bugs se detectan en desarrollo, no en producción
   - Mayor calidad del software

HERRAMIENTAS PARA TDD EN ROXFARMA:
----------------------------------
- JUnit 5: Framework de pruebas
- Mockito: Framework para crear mocks
- AssertJ: Aserciones más legibles
- Spring Boot Test: Pruebas de integración


================================================================================
6. SEGURIDAD: AUTENTICACIÓN Y AUTORIZACIÓN
================================================================================

La seguridad es fundamental en RoxFarma para proteger datos sensibles y
controlar el acceso según roles de usuario.

--------------------------------------------------------------------------------
6.1 CONCEPTOS CLAVE
--------------------------------------------------------------------------------

AUTENTICACIÓN:
- Proceso de verificar la identidad de un usuario
- Pregunta: "¿Quién eres?"
- En RoxFarma: Login con usuario y contraseña

AUTORIZACIÓN:
- Proceso de verificar qué puede hacer un usuario
- Pregunta: "¿Qué permisos tienes?"
- En RoxFarma: Roles ADMINISTRADOR y TRABAJADOR

JWT (JSON Web Token):
- Token de seguridad que contiene información del usuario
- Se envía en cada petición HTTP
- No requiere almacenar sesiones en el servidor

--------------------------------------------------------------------------------
6.2 ARQUITECTURA DE SEGURIDAD EN ROXFARMA
--------------------------------------------------------------------------------

FLUJO DE AUTENTICACIÓN:

1. Usuario ingresa credenciales (usuario, contraseña)
   ↓
2. Frontend envía POST /api/auth/login
   ↓
3. AuthController recibe la petición
   ↓
4. AuthenticationService valida credenciales
   ↓
5. Si son válidas, JwtService genera token JWT
   ↓
6. Se retorna token al frontend
   ↓
7. Frontend almacena token en localStorage
   ↓
8. En peticiones subsecuentes, frontend envía token en header:
   Authorization: Bearer <token>
   ↓
9. JwtAuthFilter intercepta la petición y valida el token
   ↓
10. Si el token es válido, permite el acceso
    ↓
11. Controller procesa la petición

DIAGRAMA:
```
┌──────────────┐
│   Cliente    │
│  (Frontend)  │
└──────────────┘
       │
       │ 1. POST /api/auth/login
       │    {usuario: "admin", contraseña: "pass"}
       ▼
┌──────────────────────┐
│  AuthController      │
└──────────────────────┘
       │
       │ 2. Validar credenciales
       ▼
┌──────────────────────┐
│ AuthenticationService│
└──────────────────────┘
       │
       │ 3. Generar JWT
       ▼
┌──────────────────────┐
│    JwtService        │
└──────────────────────┘
       │
       │ 4. Retornar token
       ▼
┌──────────────┐
│   Cliente    │ (Almacena token)
└──────────────┘
       │
       │ 5. GET /api/productos
       │    Header: Authorization: Bearer <token>
       ▼
┌──────────────────────┐
│  JwtAuthFilter       │ (Valida token)
└──────────────────────┘
       │
       │ 6. Si válido, permite acceso
       ▼
┌──────────────────────┐
│ ProductoController   │
└──────────────────────┘
```

--------------------------------------------------------------------------------
6.3 IMPLEMENTACIÓN DE SEGURIDAD
--------------------------------------------------------------------------------

A) CONFIGURACIÓN DE SPRING SECURITY
```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity // Habilita @PreAuthorize
public class SecurityConfig {
    
    private final JwtAuthFilter jwtAuthFilter;
    private final AuthenticationProvider authenticationProvider;
    
    @Autowired
    public SecurityConfig(JwtAuthFilter jwtAuthFilter,
                         AuthenticationProvider authenticationProvider) {
        this.jwtAuthFilter = jwtAuthFilter;
        this.authenticationProvider = authenticationProvider;
    }
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // Deshabilitar CSRF (no necesario para API REST con JWT)
            .csrf(csrf -> csrf.disable())
            
            // Configurar autorización de endpoints
            .authorizeHttpRequests(auth -> auth
                // Endpoints públicos (sin autenticación)
                .requestMatchers("/api/auth/**").permitAll()
                
                // Endpoints para ADMINISTRADOR y TRABAJADOR
                .requestMatchers("/api/productos/**").hasAnyRole("ADMINISTRADOR", "TRABAJADOR")
                .requestMatchers("/api/ventas/**").hasAnyRole("ADMINISTRADOR", "TRABAJADOR")
                .requestMatchers("/api/pedidos/**").hasAnyRole("ADMINISTRADOR", "TRABAJADOR")
                
                // Endpoints solo para ADMINISTRADOR
                .requestMatchers("/api/usuarios/**").hasRole("ADMINISTRADOR")
                .requestMatchers("/api/clientes/**").hasRole("ADMINISTRADOR")
                .requestMatchers("/api/proveedores/**").hasRole("ADMINISTRADOR")
                .requestMatchers("/api/reportes/**").hasRole("ADMINISTRADOR")
                
                // Cualquier otra petición requiere autenticación
                .anyRequest().authenticated()
            )
            
            // Configurar sesiones como STATELESS (sin estado)
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            
            // Configurar proveedor de autenticación
            .authenticationProvider(authenticationProvider)
            
            // Agregar filtro JWT antes del filtro de autenticación
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        // BCrypt con factor de trabajo 12 (más seguro)
        return new BCryptPasswordEncoder(12);
    }
}
```

Explicación:
- csrf().disable(): Deshabilitamos CSRF porque usamos JWT (no cookies)
- authorizeHttpRequests(): Configuramos qué roles pueden acceder a qué endpoints
- sessionCreationPolicy(STATELESS): No guardamos sesiones en el servidor
- addFilterBefore(): Agregamos nuestro filtro JWT antes del filtro de Spring

B) SERVICIO JWT
```java
@Service
public class JwtService {
    
    @Value("${jwt.secret}")
    private String secretKey; // Clave secreta para firmar tokens
    
    @Value("${jwt.expiration}")
    private Long expiration; // Tiempo de expiración (ej: 24 horas)
    
    /**
     * Genera un token JWT para un usuario
     */
    public String generarToken(Usuario usuario) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("rol", usuario.getRol().name());
        claims.put("nombre", usuario.getNombre());
        
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(usuario.getUsuario())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expiration))
            .signWith(getSigningKey(), SignatureAlgorithm.HS256)
            .compact();
    }
    
    /**
     * Extrae el nombre de usuario del token
     */
    public String extraerUsuario(String token) {
        return extraerClaim(token, Claims::getSubject);
    }
    
    /**
     * Valida si el token es válido
     */
    public boolean validarToken(String token, UserDetails userDetails) {
        final String usuario = extraerUsuario(token);
        return (usuario.equals(userDetails.getUsername()) && !tokenExpirado(token));
    }
    
    /**
     * Verifica si el token ha expirado
     */
    public boolean tokenExpirado(String token) {
        return extraerExpiracion(token).before(new Date());
    }
    
    private Date extraerExpiracion(String token) {
        return extraerClaim(token, Claims::getExpiration);
    }
    
    private <T> T extraerClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extraerTodosClaims(token);
        return claimsResolver.apply(claims);
    }
    
    private Claims extraerTodosClaims(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(getSigningKey())
            .build()
            .parseClaimsJws(token)
            .getBody();
    }
    
    private Key getSigningKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}
```

Explicación:
- generarToken(): Crea un JWT con información del usuario (claims)
- extraerUsuario(): Obtiene el nombre de usuario del token
- validarToken(): Verifica que el token sea válido y no haya expirado
- El token se firma con una clave secreta para evitar falsificaciones

C) FILTRO DE AUTENTICACIÓN JWT
```java
@Component
public class JwtAuthFilter extends OncePerRequestFilter {
    
    private final JwtService jwtService;
    private final UserDetailsService userDetailsService;
    
    @Autowired
    public JwtAuthFilter(JwtService jwtService, UserDetailsService userDetailsService) {
        this.jwtService = jwtService;
        this.userDetailsService = userDetailsService;
    }
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain filterChain) throws ServletException, IOException {
        
        // 1. Extraer token del header Authorization
        final String authHeader = request.getHeader("Authorization");
        
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }
        
        final String jwt = authHeader.substring(7); // Remover "Bearer "
        final String usuario = jwtService.extraerUsuario(jwt);
        
        // 2. Si el token contiene usuario y no hay autenticación previa
        if (usuario != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            
            // 3. Cargar detalles del usuario
            UserDetails userDetails = userDetailsService.loadUserByUsername(usuario);
            
            // 4. Validar token
            if (jwtService.validarToken(jwt, userDetails)) {
                
                // 5. Crear objeto de autenticación
                UsernamePasswordAuthenticationToken authToken = 
                    new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                    );
                
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                
                // 6. Establecer autenticación en el contexto de seguridad
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        
        // 7. Continuar con la cadena de filtros
        filterChain.doFilter(request, response);
    }
}
```

D) SERVICIO DE AUTENTICACIÓN
```java
@Service
public class AuthenticationService {
    
    private final AuthenticationManager authenticationManager;
    private final UsuarioRepository usuarioRepository;
    private final JwtService jwtService;
    
    @Autowired
    public AuthenticationService(AuthenticationManager authenticationManager,
                                 UsuarioRepository usuarioRepository,
                                 JwtService jwtService) {
        this.authenticationManager = authenticationManager;
        this.usuarioRepository = usuarioRepository;
        this.jwtService = jwtService;
    }
    
    public AuthResponse login(LoginRequest request) {
        // 1. Autenticar usuario con Spring Security
        authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(
                request.getUsuario(),
                request.getContrasena()
            )
        );
        
        // 2. Si llega aquí, las credenciales son válidas
        Usuario usuario = usuarioRepository.findByUsuario(request.getUsuario())
            .orElseThrow(() -> new ResourceNotFoundException("Usuario no encontrado"));
        
        // 3. Generar token JWT
        String token = jwtService.generarToken(usuario);
        
        // 4. Retornar respuesta con token
        return new AuthResponse(
            token,
            "Bearer",
            usuario.getIdUsuario(),
            usuario.getNombre(),
            usuario.getRol()
        );
    }
}
```

E) CIFRADO DE CONTRASEÑAS
```java
@Service
public class UsuarioService {
    
    private final UsuarioRepository usuarioRepository;
    private final PasswordEncoder passwordEncoder;
    
    @Autowired
    public UsuarioService(UsuarioRepository usuarioRepository,
                         PasswordEncoder passwordEncoder) {
        this.usuarioRepository = usuarioRepository;
        this.passwordEncoder = passwordEncoder;
    }
    
    public Usuario crearUsuario(UsuarioDTO dto) {
        Usuario usuario = new Usuario();
        usuario.setNombre(dto.getNombre());
        usuario.setUsuario(dto.getUsuario());
        
        // Cifrar contraseña con BCrypt antes de guardar
        String contrasenaCifrada = passwordEncoder.encode(dto.getContrasena());
        usuario.setContrasena(contrasenaCifrada);
        
        usuario.setRol(dto.getRol());
        
        return usuarioRepository.save(usuario);
    }
}
```

Explicación:
- BCrypt es un algoritmo de cifrado de una vía (no se puede descifrar)
- Cada vez que se cifra la misma contraseña, genera un hash diferente (salt)
- Factor de trabajo 12 significa 2^12 iteraciones (más seguro pero más lento)

Ejemplo de contraseña cifrada:
```
Contraseña original: password123
Hash BCrypt: $2a$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYIR.eLb4W6
```

F) AUTORIZACIÓN POR ROLES EN CONTROLADORES
```java
@RestController
@RequestMapping("/api/productos")
public class ProductoController {
    
    private final ProductoService productoService;
    
    @Autowired
    public ProductoController(ProductoService productoService) {
        this.productoService = productoService;
    }
    
    // Accesible para ADMINISTRADOR y TRABAJADOR
    @GetMapping
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'TRABAJADOR')")
    public ResponseEntity<List<Producto>> listarProductos() {
        List<Producto> productos = productoService.listarTodosLosProductos();
        return ResponseEntity.ok(productos);
    }
    
    // Solo ADMINISTRADOR puede crear productos
    @PostMapping
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<Producto> crearProducto(@Valid @RequestBody ProductoDTO dto) {
        Producto producto = productoService.crearProducto(dto);
        return ResponseEntity.ok(producto);
    }
    
    // Solo ADMINISTRADOR puede eliminar productos
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<Void> eliminarProducto(@PathVariable Long id) {
        productoService.eliminarProducto(id);
        return ResponseEntity.noContent().build();
    }
}
```

--------------------------------------------------------------------------------
6.4 ROLES Y PERMISOS EN ROXFARMA
--------------------------------------------------------------------------------

ADMINISTRADOR:
- Acceso completo a todos los módulos
- Puede gestionar usuarios (crear, editar, eliminar)
- Puede gestionar productos, categorías
- Puede gestionar clientes y proveedores
- Puede registrar ventas y pedidos
- Puede ver reportes y estadísticas
- Puede acceder a auditoría

TRABAJADOR:
- Acceso limitado a operaciones diarias
- Puede registrar ventas
- Puede registrar pedidos
- Puede consultar inventario
- Puede ver alertas de stock
- NO puede gestionar usuarios
- NO puede ver reportes
- NO puede gestionar clientes/proveedores

TABLA DE PERMISOS:
```
Módulo              | ADMINISTRADOR | TRABAJADOR
--------------------|---------------|------------
Usuarios            |      ✓        |     ✗
Productos           |      ✓        |     ✓ (solo lectura)
Categorías          |      ✓        |     ✗
Clientes            |      ✓        |     ✗
Proveedores         |      ✓        |     ✗
Ventas              |      ✓        |     ✓
Pedidos             |      ✓        |     ✓
Inventario          |      ✓        |     ✓ (solo lectura)
Reportes            |      ✓        |     ✗
Auditoría           |      ✓        |     ✗
```

--------------------------------------------------------------------------------
6.5 MANEJO DE ERRORES DE SEGURIDAD
--------------------------------------------------------------------------------

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    // Error 401: No autenticado
    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity<ErrorResponse> handleBadCredentials(BadCredentialsException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.UNAUTHORIZED.value(),
            "Usuario o contraseña incorrectos",
            LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);
    }
    
    // Error 403: No autorizado (sin permisos)
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDenied(AccessDeniedException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.FORBIDDEN.value(),
            "No tiene permisos para acceder a este recurso",
            LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }
}
```

CÓDIGOS HTTP DE SEGURIDAD:
- 401 Unauthorized: Usuario no autenticado (no ha iniciado sesión o token inválido)
- 403 Forbidden: Usuario autenticado pero sin permisos para la operación
- 200 OK: Operación exitosa
- 201 Created: Recurso creado exitosamente

--------------------------------------------------------------------------------
6.6 BUENAS PRÁCTICAS DE SEGURIDAD EN ROXFARMA
--------------------------------------------------------------------------------

1. NUNCA almacenar contraseñas en texto plano
   ✓ Usar BCrypt para cifrar contraseñas

2. NUNCA exponer información sensible en mensajes de error
   ✗ "Usuario 'admin' no encontrado"
   ✓ "Usuario o contraseña incorrectos"

3. USAR HTTPS en producción
   - Cifra la comunicación entre cliente y servidor
   - Protege el token JWT en tránsito

4. VALIDAR datos de entrada
   - Usar @Valid en DTOs
   - Prevenir inyección SQL con PreparedStatement (JPA lo hace automáticamente)

5. IMPLEMENTAR rate limiting
   - Limitar intentos de login fallidos
   - Prevenir ataques de fuerza bruta

6. EXPIRAR tokens JWT
   - Tokens con tiempo de vida limitado (ej: 24 horas)
   - Forzar re-autenticación periódica

7. REGISTRAR operaciones en auditoría
   - Quién hizo qué y cuándo
   - Trazabilidad completa

8. PRINCIPIO DE MÍNIMO PRIVILEGIO
   - Dar solo los permisos necesarios
   - TRABAJADOR no necesita acceso a usuarios


================================================================================
7. FLUJO COMPLETO DE UNA OPERACIÓN: REGISTRAR VENTA
================================================================================

Vamos a seguir el flujo completo de registrar una venta, desde que el usuario
hace clic en el botón hasta que se actualiza la base de datos.

PASO 1: USUARIO HACE CLIC EN "REGISTRAR VENTA" (Frontend)
```typescript
// components/ventas/VentaForm.tsx
const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
        // Preparar datos
        const ventaDTO = {
            idCliente: clienteSeleccionado,
            detalles: productosSeleccionados.map(p => ({
                idProducto: p.id,
                cantidad: p.cantidad
            }))
        };
        
        // Llamar al servicio
        const venta = await ventaService.registrarVenta(ventaDTO);
        
        // Mostrar mensaje de éxito
        alert('Venta registrada exitosamente');
        
        // Descargar boleta
        await ventaService.descargarBoleta(venta.idVenta);
        
    } catch (error) {
        alert('Error al registrar venta: ' + error.message);
    }
};
```

PASO 2: SERVICIO FRONTEND ENVÍA PETICIÓN HTTP (Frontend)
```typescript
// services/ventaService.ts
export const ventaService = {
    registrarVenta: async (dto: VentaDTO): Promise<Venta> => {
        const response = await api.post('/api/ventas', dto);
        return response.data;
    }
};

// services/api.ts
const api = axios.create({
    baseURL: 'http://localhost:8080/api'
});

// Interceptor que agrega token JWT
api.interceptors.request.use(config => {
    const token = localStorage.getItem('token');
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});
```

PASO 3: PETICIÓN LLEGA AL SERVIDOR (Backend)
```
POST http://localhost:8080/api/ventas
Headers:
  Content-Type: application/json
  Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Body:
{
  "idCliente": 1,
  "detalles": [
    { "idProducto": 1, "cantidad": 5 },
    { "idProducto": 2, "cantidad": 3 }
  ]
}
```

PASO 4: FILTRO JWT VALIDA EL TOKEN (Backend - Seguridad)
```java
// JwtAuthFilter intercepta la petición
@Override
protected void doFilterInternal(HttpServletRequest request, ...) {
    // 1. Extraer token del header
    String jwt = request.getHeader("Authorization").substring(7);
    
    // 2. Validar token
    String usuario = jwtService.extraerUsuario(jwt);
    UserDetails userDetails = userDetailsService.loadUserByUsername(usuario);
    
    if (jwtService.validarToken(jwt, userDetails)) {
        // 3. Token válido, establecer autenticación
        SecurityContextHolder.getContext().setAuthentication(authToken);
    }
    
    // 4. Continuar con la petición
    filterChain.doFilter(request, response);
}
```

PASO 5: CONTROLADOR RECIBE LA PETICIÓN (Backend - Controller)
```java
@RestController
@RequestMapping("/api/ventas")
public class VentaController {
    
    private final VentaService ventaService;
    
    @PostMapping
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'TRABAJADOR')")
    public ResponseEntity<Venta> registrarVenta(@Valid @RequestBody VentaDTO dto) {
        // 1. Spring valida el DTO con @Valid
        // 2. Spring verifica autorización con @PreAuthorize
        // 3. Delegar al servicio
        Venta venta = ventaService.registrarVenta(dto);
        
        // 4. Retornar respuesta
        return ResponseEntity.ok(venta);
    }
}
```

PASO 6: SERVICIO PROCESA LA LÓGICA DE NEGOCIO (Backend - Service)
```java
@Service
@Transactional
public class VentaService {
    
    private final VentaRepository ventaRepository;
    private final ProductoRepository productoRepository;
    private final ClienteRepository clienteRepository;
    private final InventarioService inventarioService;
    
    public Venta registrarVenta(VentaDTO dto) {
        log.info("Iniciando registro de venta para cliente ID: {}", dto.getIdCliente());
        
        // 1. Validar que el cliente existe
        Cliente cliente = clienteRepository.findById(dto.getIdCliente())
            .orElseThrow(() -> new ResourceNotFoundException(
                "Cliente no encontrado con ID: " + dto.getIdCliente()
            ));
        
        // 2. Validar productos y stock
        for (DetalleVentaDTO detalleDTO : dto.getDetalles()) {
            Producto producto = productoRepository.findById(detalleDTO.getIdProducto())
                .orElseThrow(() -> new ResourceNotFoundException(
                    "Producto no encontrado con ID: " + detalleDTO.getIdProducto()
                ));
            
            // Validar stock suficiente
            if (producto.getStock() < detalleDTO.getCantidad()) {
                throw new StockInsuficienteException(
                    String.format("Stock insuficiente para %s. Disponible: %d, Solicitado: %d",
                        producto.getNombre(), producto.getStock(), detalleDTO.getCantidad())
                );
            }
        }
        
        // 3. Crear venta
        Venta venta = new Venta();
        venta.setCliente(cliente);
        venta.setFecha(LocalDateTime.now());
        venta.setUsuario(obtenerUsuarioActual());
        
        // 4. Crear detalles y calcular total
        List<DetalleVenta> detalles = new ArrayList<>();
        BigDecimal subtotal = BigDecimal.ZERO;
        
        for (DetalleVentaDTO detalleDTO : dto.getDetalles()) {
            Producto producto = productoRepository.findById(detalleDTO.getIdProducto()).get();
            
            DetalleVenta detalle = new DetalleVenta();
            detalle.setVenta(venta);
            detalle.setProducto(producto);
            detalle.setCantidad(detalleDTO.getCantidad());
            detalle.setPrecio(producto.getPrecio());
            
            detalles.add(detalle);
            
            // Calcular subtotal
            BigDecimal precioDetalle = producto.getPrecio()
                .multiply(BigDecimal.valueOf(detalleDTO.getCantidad()));
            subtotal = subtotal.add(precioDetalle);
        }
        
        venta.setDetalles(detalles);
        
        // 5. Calcular IGV y total
        BigDecimal igv = subtotal.multiply(new BigDecimal("0.18"));
        BigDecimal total = subtotal.add(igv);
        venta.setTotal(total);
        
        // 6. Guardar venta (transaccional)
        venta = ventaRepository.save(venta);
        
        // 7. Actualizar inventario
        for (DetalleVenta detalle : detalles) {
            inventarioService.disminuirStock(
                detalle.getProducto().getIdProducto(),
                detalle.getCantidad(),
                "VENTA"
            );
        }
        
        log.info("Venta registrada exitosamente. ID: {}, Total: {}", 
            venta.getIdVenta(), venta.getTotal());
        
        return venta;
    }
}
```

PASO 7: REPOSITORIO GUARDA EN BASE DE DATOS (Backend - Repository/DAO)
```java
@Repository
public interface VentaRepository extends JpaRepository<Venta, Long> {
    // Spring Data JPA genera automáticamente:
    // - save(Venta): INSERT o UPDATE
    // - findById(Long): SELECT
    // - findAll(): SELECT *
    // - delete(Venta): DELETE
}

// Cuando llamamos ventaRepository.save(venta), Spring ejecuta:
INSERT INTO venta (fecha, id_cliente, id_usuario, total) 
VALUES ('2024-10-17 10:30:00', 1, 1, 413.00);

INSERT INTO detalle_venta (id_venta, id_producto, cantidad, precio) 
VALUES (1, 1, 5, 15.00);

INSERT INTO detalle_venta (id_venta, id_producto, cantidad, precio) 
VALUES (1, 2, 3, 50.00);
```

PASO 8: INVENTARIO SE ACTUALIZA (Backend - Service)
```java
@Service
@Transactional
public class InventarioService {
    
    private final ProductoRepository productoRepository;
    private final AuditoriaRepository auditoriaRepository;
    
    public void disminuirStock(Long idProducto, Integer cantidad, String motivo) {
        log.info("Disminuyendo stock del producto ID: {} en {} unidades", idProducto, cantidad);
        
        // 1. Buscar producto
        Producto producto = productoRepository.findById(idProducto)
            .orElseThrow(() -> new ResourceNotFoundException("Producto no encontrado"));
        
        // 2. Validar stock suficiente
        if (producto.getStock() < cantidad) {
            throw new StockInsuficienteException("Stock insuficiente");
        }
        
        // 3. Actualizar stock
        producto.setStock(producto.getStock() - cantidad);
        productoRepository.save(producto);
        
        // 4. Registrar en auditoría
        registrarMovimiento(producto, cantidad, motivo, "SALIDA");
        
        log.info("Stock actualizado. Producto: {}, Stock nuevo: {}", 
            producto.getNombre(), producto.getStock());
    }
}

// SQL ejecutado:
UPDATE producto SET stock = stock - 5 WHERE id_producto = 1;
UPDATE producto SET stock = stock - 3 WHERE id_producto = 2;
```

PASO 9: RESPUESTA RETORNA AL FRONTEND (Backend → Frontend)
```java
// Controller retorna ResponseEntity
return ResponseEntity.ok(venta);

// Spring convierte la entidad Venta a JSON:
{
  "idVenta": 1,
  "fecha": "2024-10-17T10:30:00",
  "cliente": {
    "idCliente": 1,
    "nombre": "Farmacia San Juan"
  },
  "total": 413.00,
  "detalles": [
    {
      "idDetalleVenta": 1,
      "producto": { "idProducto": 1, "nombre": "Paracetamol" },
      "cantidad": 5,
      "precio": 15.00
    },
    {
      "idDetalleVenta": 2,
      "producto": { "idProducto": 2, "nombre": "Ibuprofeno" },
      "cantidad": 3,
      "precio": 50.00
    }
  ]
}
```

PASO 10: FRONTEND PROCESA LA RESPUESTA
```typescript
// El servicio recibe la respuesta
const venta = await ventaService.registrarVenta(ventaDTO);

// Mostrar mensaje de éxito
alert('Venta registrada exitosamente');

// Descargar boleta PDF
await ventaService.descargarBoleta(venta.idVenta);
```

RESUMEN DEL FLUJO:
1. Usuario → Frontend (React)
2. Frontend → HTTP Request (Axios)
3. Backend → Filtro JWT (Seguridad)
4. Backend → Controller (Recibe petición)
5. Backend → Service (Lógica de negocio)
6. Backend → Repository (Acceso a datos)
7. Backend → Base de Datos (MySQL)
8. Base de Datos → Repository (Resultado)
9. Repository → Service → Controller
10. Controller → HTTP Response (JSON)
11. Frontend → Procesa respuesta
12. Frontend → Actualiza UI


================================================================================
8. EJEMPLOS DE CÓDIGO COMENTADOS PARA EXPOSICIÓN
================================================================================

--------------------------------------------------------------------------------
8.1 EJEMPLO COMPLETO: ENTIDAD JPA
--------------------------------------------------------------------------------

```java
/**
 * Entidad que representa un Producto en el sistema RoxFarma.
 * Esta clase es parte del MODELO en la arquitectura MVC.
 * 
 * Anotaciones JPA:
 * - @Entity: Marca la clase como entidad persistente
 * - @Table: Especifica el nombre de la tabla en la base de datos
 * - @Id: Marca el campo como clave primaria
 * - @GeneratedValue: Indica que el ID se genera automáticamente
 * - @ManyToOne: Relación muchos a uno con Categoria
 */
@Entity
@Table(name = "producto")
@Getter @Setter // Lombok genera getters y setters automáticamente
public class Producto {
    
    /**
     * Identificador único del producto.
     * Se genera automáticamente con estrategia IDENTITY (auto-increment en MySQL).
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long idProducto;
    
    /**
     * Nombre del producto (ej: "Paracetamol 500mg").
     * Campo obligatorio, no puede ser nulo.
     */
    @Column(nullable = false, length = 200)
    private String nombre;
    
    /**
     * Descripción detallada del producto.
     * Campo opcional, puede contener texto largo.
     */
    @Column(columnDefinition = "TEXT")
    private String descripcion;
    
    /**
     * Precio unitario del producto en soles.
     * Usa BigDecimal para precisión en cálculos monetarios.
     * precision=10: hasta 10 dígitos en total
     * scale=2: 2 dígitos decimales (ej: 999999.99)
     */
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal precio;
    
    /**
     * Fecha de vencimiento del producto.
     * Se usa para generar alertas de productos próximos a vencer.
     */
    @Column(nullable = false)
    private LocalDate fechaVencimiento;
    
    /**
     * Cantidad disponible en inventario.
     * Se actualiza automáticamente al registrar ventas y pedidos.
     */
    @Column(nullable = false)
    private Integer stock;
    
    /**
     * Relación muchos a uno con Categoria.
     * Muchos productos pertenecen a una categoría.
     * 
     * @ManyToOne: Indica la relación
     * @JoinColumn: Especifica la columna de clave foránea
     * fetch = LAZY: La categoría se carga solo cuando se accede
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id_categoria", nullable = false)
    private Categoria categoria;
    
    /**
     * Fecha de creación del registro.
     * Se establece automáticamente al crear el producto.
     */
    @Column(updatable = false)
    private LocalDateTime fechaCreacion;
    
    /**
     * Fecha de última actualización.
     * Se actualiza automáticamente cada vez que se modifica el producto.
     */
    private LocalDateTime fechaActualizacion;
    
    /**
     * Método que se ejecuta antes de persistir (INSERT).
     * Establece la fecha de creación.
     */
    @PrePersist
    protected void onCreate() {
        fechaCreacion = LocalDateTime.now();
        fechaActualizacion = LocalDateTime.now();
    }
    
    /**
     * Método que se ejecuta antes de actualizar (UPDATE).
     * Actualiza la fecha de modificación.
     */
    @PreUpdate
    protected void onUpdate() {
        fechaActualizacion = LocalDateTime.now();
    }
}
```

--------------------------------------------------------------------------------
8.2 EJEMPLO COMPLETO: SERVICIO CON INYECCIÓN DE DEPENDENCIAS
--------------------------------------------------------------------------------

```java
/**
 * Servicio que contiene la lógica de negocio para gestión de productos.
 * Esta clase es parte de la CAPA DE SERVICIO en la arquitectura multicapa.
 * 
 * Aplica principios SOLID:
 * - S: Responsabilidad única (solo lógica de productos)
 * - O: Abierto/Cerrado (extensible mediante interfaces)
 * - D: Inversión de dependencias (depende de interfaces, no implementaciones)
 * 
 * Usa Inyección de Dependencias:
 * - Las dependencias se inyectan mediante constructor
 * - Spring gestiona el ciclo de vida de los objetos
 * - Facilita pruebas unitarias con mocks
 */
@Service // Marca la clase como servicio de Spring
@Slf4j   // Lombok genera logger automáticamente
public class ProductoService {
    
    // Dependencias declaradas como interfaces (Inversión de Dependencias)
    private final ProductoRepository productoRepository;
    private final CategoriaRepository categoriaRepository;
    
    /**
     * Constructor para inyección de dependencias.
     * 
     * @Autowired es opcional en constructores únicos desde Spring 4.3
     * 
     * Ventajas de inyección por constructor:
     * 1. Dependencias inmutables (final)
     * 2. Fácil de probar (se pueden inyectar mocks)
     * 3. Dependencias obligatorias (no pueden ser null)
     * 4. Recomendada por Spring
     */
    @Autowired
    public ProductoService(ProductoRepository productoRepository,
                          CategoriaRepository categoriaRepository) {
        this.productoRepository = productoRepository;
        this.categoriaRepository = categoriaRepository;
    }
    
    /**
     * Crea un nuevo producto en el sistema.
     * 
     * Flujo:
     * 1. Validar que la categoría existe
     * 2. Mapear DTO a entidad
     * 3. Guardar en base de datos
     * 4. Retornar producto creado
     * 
     * @param dto Datos del producto a crear
     * @return Producto creado con ID generado
     * @throws ResourceNotFoundException si la categoría no existe
     */
    public Producto crearProducto(ProductoDTO dto) {
        log.info("Creando producto: {}", dto.getNombre());
        
        // 1. Validar que la categoría existe
        Categoria categoria = categoriaRepository.findById(dto.getIdCategoria())
            .orElseThrow(() -> new ResourceNotFoundException(
                "Categoría no encontrada con ID: " + dto.getIdCategoria()
            ));
        
        // 2. Mapear DTO a entidad
        Producto producto = new Producto();
        producto.setNombre(dto.getNombre());
        producto.setDescripcion(dto.getDescripcion());
        producto.setPrecio(dto.getPrecio());
        producto.setStock(dto.getStock());
        producto.setFechaVencimiento(dto.getFechaVencimiento());
        producto.setCategoria(categoria);
        
        // 3. Guardar en base de datos (delegado al Repository/DAO)
        Producto productoGuardado = productoRepository.save(producto);
        
        log.info("Producto creado exitosamente con ID: {}", productoGuardado.getIdProducto());
        
        // 4. Retornar producto creado
        return productoGuardado;
    }
    
    /**
     * Obtiene productos con stock por debajo del umbral especificado.
     * Usado para generar alertas de stock bajo.
     * 
     * @param umbral Cantidad mínima de stock
     * @return Lista de productos con stock bajo
     */
    public List<Producto> obtenerProductosConStockBajo(Integer umbral) {
        log.info("Buscando productos con stock menor a: {}", umbral);
        
        // Delegar consulta al Repository (patrón DAO)
        List<Producto> productos = productoRepository.findByStockLessThan(umbral);
        
        log.info("Se encontraron {} productos con stock bajo", productos.size());
        
        return productos;
    }
    
    /**
     * Obtiene productos próximos a vencer.
     * 
     * @param dias Días de anticipación para la alerta
     * @return Lista de productos próximos a vencer
     */
    public List<Producto> obtenerProductosProximosAVencer(Integer dias) {
        log.info("Buscando productos que vencen en los próximos {} días", dias);
        
        // Calcular fecha límite
        LocalDate fechaLimite = LocalDate.now().plusDays(dias);
        
        // Consultar productos que vencen antes de la fecha límite
        List<Producto> productos = productoRepository.findByFechaVencimientoBefore(fechaLimite);
        
        log.info("Se encontraron {} productos próximos a vencer", productos.size());
        
        return productos;
    }
}
```

EXPLICACIÓN PARA LA EXPOSICIÓN:
-------------------------------
1. La clase usa @Service para que Spring la detecte y gestione
2. Las dependencias se inyectan por constructor (mejor práctica)
3. Usa interfaces (Repository) en lugar de implementaciones concretas
4. Cada método tiene una responsabilidad clara
5. Se registran operaciones importantes con logging
6. Las excepciones son descriptivas y específicas
7. El código es fácil de probar con mocks


--------------------------------------------------------------------------------
8.3 EJEMPLO COMPLETO: CONTROLADOR REST
--------------------------------------------------------------------------------

```java
/**
 * Controlador REST para gestión de productos.
 * Esta clase es parte del CONTROLADOR en la arquitectura MVC.
 * 
 * Responsabilidades:
 * - Recibir peticiones HTTP
 * - Validar datos de entrada
 * - Delegar lógica de negocio al servicio
 * - Retornar respuestas HTTP
 * 
 * NO debe contener lógica de negocio (eso va en el servicio).
 */
@RestController // Combina @Controller + @ResponseBody (retorna JSON automáticamente)
@RequestMapping("/api/productos") // Ruta base para todos los endpoints
@Slf4j
public class ProductoController {
    
    // Inyección de dependencias del servicio
    private final ProductoService productoService;
    
    @Autowired
    public ProductoController(ProductoService productoService) {
        this.productoService = productoService;
    }
    
    /**
     * Endpoint: GET /api/productos
     * Retorna lista de todos los productos.
     * 
     * Accesible para: ADMINISTRADOR y TRABAJADOR
     * 
     * Respuesta exitosa: 200 OK con lista de productos en JSON
     */
    @GetMapping
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'TRABAJADOR')")
    public ResponseEntity<List<Producto>> listarProductos() {
        log.info("GET /api/productos - Listando todos los productos");
        
        // Delegar al servicio
        List<Producto> productos = productoService.listarTodosLosProductos();
        
        // Retornar respuesta HTTP 200 OK con los productos
        return ResponseEntity.ok(productos);
    }
    
    /**
     * Endpoint: GET /api/productos/{id}
     * Retorna un producto específico por ID.
     * 
     * @param id Identificador del producto
     * @return Producto encontrado
     * 
     * Respuestas:
     * - 200 OK: Producto encontrado
     * - 404 NOT FOUND: Producto no existe
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'TRABAJADOR')")
    public ResponseEntity<Producto> obtenerProducto(@PathVariable Long id) {
        log.info("GET /api/productos/{} - Obteniendo producto", id);
        
        Producto producto = productoService.obtenerProductoPorId(id);
        
        return ResponseEntity.ok(producto);
    }
    
    /**
     * Endpoint: POST /api/productos
     * Crea un nuevo producto.
     * 
     * Solo ADMINISTRADOR puede crear productos.
     * 
     * @param dto Datos del producto a crear
     * @return Producto creado con ID generado
     * 
     * @Valid: Valida el DTO antes de procesar
     * - Verifica que campos obligatorios no sean nulos
     * - Verifica que el precio sea mayor a 0
     * - Verifica que el stock no sea negativo
     * 
     * Respuestas:
     * - 200 OK: Producto creado exitosamente
     * - 400 BAD REQUEST: Datos inválidos
     * - 403 FORBIDDEN: Usuario no es ADMINISTRADOR
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<Producto> crearProducto(@Valid @RequestBody ProductoDTO dto) {
        log.info("POST /api/productos - Creando producto: {}", dto.getNombre());
        
        // @Valid valida automáticamente el DTO
        // Si hay errores, Spring lanza MethodArgumentNotValidException
        // que es manejada por GlobalExceptionHandler
        
        Producto producto = productoService.crearProducto(dto);
        
        return ResponseEntity.ok(producto);
    }
    
    /**
     * Endpoint: PUT /api/productos/{id}
     * Actualiza un producto existente.
     * 
     * Solo ADMINISTRADOR puede actualizar productos.
     * 
     * @param id ID del producto a actualizar
     * @param dto Nuevos datos del producto
     * @return Producto actualizado
     * 
     * Respuestas:
     * - 200 OK: Producto actualizado
     * - 400 BAD REQUEST: Datos inválidos
     * - 403 FORBIDDEN: Usuario no es ADMINISTRADOR
     * - 404 NOT FOUND: Producto no existe
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<Producto> actualizarProducto(
            @PathVariable Long id,
            @Valid @RequestBody ProductoDTO dto) {
        
        log.info("PUT /api/productos/{} - Actualizando producto", id);
        
        Producto producto = productoService.actualizarProducto(id, dto);
        
        return ResponseEntity.ok(producto);
    }
    
    /**
     * Endpoint: DELETE /api/productos/{id}
     * Elimina un producto.
     * 
     * Solo ADMINISTRADOR puede eliminar productos.
     * 
     * @param id ID del producto a eliminar
     * @return Respuesta sin contenido
     * 
     * Respuestas:
     * - 204 NO CONTENT: Producto eliminado exitosamente
     * - 403 FORBIDDEN: Usuario no es ADMINISTRADOR
     * - 404 NOT FOUND: Producto no existe
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<Void> eliminarProducto(@PathVariable Long id) {
        log.info("DELETE /api/productos/{} - Eliminando producto", id);
        
        productoService.eliminarProducto(id);
        
        // 204 NO CONTENT: Operación exitosa sin contenido en la respuesta
        return ResponseEntity.noContent().build();
    }
    
    /**
     * Endpoint: GET /api/productos/alertas/stock-bajo
     * Retorna productos con stock por debajo del umbral.
     * 
     * Usado para el dashboard de alertas.
     * 
     * @return Lista de productos con stock bajo
     */
    @GetMapping("/alertas/stock-bajo")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'TRABAJADOR')")
    public ResponseEntity<List<Producto>> obtenerStockBajo() {
        log.info("GET /api/productos/alertas/stock-bajo");
        
        // Umbral de 10 unidades
        List<Producto> productos = productoService.obtenerProductosConStockBajo(10);
        
        return ResponseEntity.ok(productos);
    }
    
    /**
     * Endpoint: GET /api/productos/alertas/proximos-vencer
     * Retorna productos que vencen en los próximos 30 días.
     * 
     * Usado para el dashboard de alertas.
     * 
     * @return Lista de productos próximos a vencer
     */
    @GetMapping("/alertas/proximos-vencer")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'TRABAJADOR')")
    public ResponseEntity<List<Producto>> obtenerProximosVencer() {
        log.info("GET /api/productos/alertas/proximos-vencer");
        
        // Alertar con 30 días de anticipación
        List<Producto> productos = productoService.obtenerProductosProximosAVencer(30);
        
        return ResponseEntity.ok(productos);
    }
}
```

ANOTACIONES IMPORTANTES:
-----------------------
@RestController: Marca la clase como controlador REST
@RequestMapping: Define la ruta base
@GetMapping: Maneja peticiones GET
@PostMapping: Maneja peticiones POST
@PutMapping: Maneja peticiones PUT
@DeleteMapping: Maneja peticiones DELETE
@PathVariable: Extrae variable de la URL
@RequestBody: Extrae datos del cuerpo de la petición
@Valid: Valida el objeto antes de procesarlo
@PreAuthorize: Controla acceso según roles

CÓDIGOS HTTP:
------------
200 OK: Operación exitosa
201 CREATED: Recurso creado
204 NO CONTENT: Operación exitosa sin contenido
400 BAD REQUEST: Datos inválidos
401 UNAUTHORIZED: No autenticado
403 FORBIDDEN: Sin permisos
404 NOT FOUND: Recurso no encontrado
500 INTERNAL SERVER ERROR: Error del servidor

================================================================================
CONCLUSIÓN
================================================================================

El Sistema RoxFarma implementa las mejores prácticas de desarrollo de software:

1. ARQUITECTURA MVC: Separación clara de responsabilidades
2. PATRÓN DAO: Encapsulación del acceso a datos
3. PRINCIPIOS SOLID: Código mantenible y escalable
4. INYECCIÓN DE DEPENDENCIAS: Desacoplamiento y testabilidad
5. TDD: Código confiable con pruebas automatizadas
6. SEGURIDAD: Autenticación JWT y autorización por roles
7. LOGGING: Trazabilidad completa de operaciones
8. MANEJO DE ERRORES: Excepciones personalizadas y respuestas claras

Estos principios garantizan un sistema robusto, seguro y fácil de mantener,
cumpliendo con los estándares académicos y profesionales de la industria.

================================================================================
FIN DEL DOCUMENTO
================================================================================
